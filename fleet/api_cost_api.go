/*
Omnistrate Fleet API

REST API for Omnistrate Fleet

API version: 2022-09-01-00
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fleet

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"time"
)


type CostApiAPI interface {

	/*
	CostApiDescribeCloudProviderCost DescribeCloudProviderCost cost-api

	Get the total cost of operating a fleet on a cloud provider

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCostApiDescribeCloudProviderCostRequest
	*/
	CostApiDescribeCloudProviderCost(ctx context.Context) ApiCostApiDescribeCloudProviderCostRequest

	// CostApiDescribeCloudProviderCostExecute executes the request
	//  @return DescribeCloudProviderCostResult
	CostApiDescribeCloudProviderCostExecute(r ApiCostApiDescribeCloudProviderCostRequest) (*DescribeCloudProviderCostResult, *http.Response, error)

	/*
	CostApiDescribeDeploymentCellCost DescribeDeploymentCellCost cost-api

	Get the total cost of operating a fleet in a deployment cell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCostApiDescribeDeploymentCellCostRequest
	*/
	CostApiDescribeDeploymentCellCost(ctx context.Context) ApiCostApiDescribeDeploymentCellCostRequest

	// CostApiDescribeDeploymentCellCostExecute executes the request
	//  @return DescribeDeploymentCellCostResult
	CostApiDescribeDeploymentCellCostExecute(r ApiCostApiDescribeDeploymentCellCostRequest) (*DescribeDeploymentCellCostResult, *http.Response, error)

	/*
	CostApiDescribeRegionCost DescribeRegionCost cost-api

	Get the total cost of operating a fleet in a region

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCostApiDescribeRegionCostRequest
	*/
	CostApiDescribeRegionCost(ctx context.Context) ApiCostApiDescribeRegionCostRequest

	// CostApiDescribeRegionCostExecute executes the request
	//  @return DescribeRegionCostResult
	CostApiDescribeRegionCostExecute(r ApiCostApiDescribeRegionCostRequest) (*DescribeRegionCostResult, *http.Response, error)

	/*
	CostApiDescribeUserCost DescribeUserCost cost-api

	Get the total cost of operating a fleet for a user

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCostApiDescribeUserCostRequest
	*/
	CostApiDescribeUserCost(ctx context.Context) ApiCostApiDescribeUserCostRequest

	// CostApiDescribeUserCostExecute executes the request
	//  @return DescribeUserCostResult
	CostApiDescribeUserCostExecute(r ApiCostApiDescribeUserCostRequest) (*DescribeUserCostResult, *http.Response, error)
}

// CostApiAPIService CostApiAPI service
type CostApiAPIService service

type ApiCostApiDescribeCloudProviderCostRequest struct {
	ctx context.Context
	ApiService CostApiAPI
	startDate *time.Time
	endDate *time.Time
	environmentType *string
	frequency *string
	includeCloudProviderIDs *string
	excludeCloudProviderIDs *string
}

// The start date of the range
func (r ApiCostApiDescribeCloudProviderCostRequest) StartDate(startDate time.Time) ApiCostApiDescribeCloudProviderCostRequest {
	r.startDate = &startDate
	return r
}

// The end date of the range
func (r ApiCostApiDescribeCloudProviderCostRequest) EndDate(endDate time.Time) ApiCostApiDescribeCloudProviderCostRequest {
	r.endDate = &endDate
	return r
}

// The type of environment to filter costs by
func (r ApiCostApiDescribeCloudProviderCostRequest) EnvironmentType(environmentType string) ApiCostApiDescribeCloudProviderCostRequest {
	r.environmentType = &environmentType
	return r
}

// The frequency of the cost data
func (r ApiCostApiDescribeCloudProviderCostRequest) Frequency(frequency string) ApiCostApiDescribeCloudProviderCostRequest {
	r.frequency = &frequency
	return r
}

// The cloud provider IDs to include in the cost data
func (r ApiCostApiDescribeCloudProviderCostRequest) IncludeCloudProviderIDs(includeCloudProviderIDs string) ApiCostApiDescribeCloudProviderCostRequest {
	r.includeCloudProviderIDs = &includeCloudProviderIDs
	return r
}

// The cloud provider IDs to exclude from the cost data
func (r ApiCostApiDescribeCloudProviderCostRequest) ExcludeCloudProviderIDs(excludeCloudProviderIDs string) ApiCostApiDescribeCloudProviderCostRequest {
	r.excludeCloudProviderIDs = &excludeCloudProviderIDs
	return r
}

func (r ApiCostApiDescribeCloudProviderCostRequest) Execute() (*DescribeCloudProviderCostResult, *http.Response, error) {
	return r.ApiService.CostApiDescribeCloudProviderCostExecute(r)
}

/*
CostApiDescribeCloudProviderCost DescribeCloudProviderCost cost-api

Get the total cost of operating a fleet on a cloud provider

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCostApiDescribeCloudProviderCostRequest
*/
func (a *CostApiAPIService) CostApiDescribeCloudProviderCost(ctx context.Context) ApiCostApiDescribeCloudProviderCostRequest {
	return ApiCostApiDescribeCloudProviderCostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeCloudProviderCostResult
func (a *CostApiAPIService) CostApiDescribeCloudProviderCostExecute(r ApiCostApiDescribeCloudProviderCostRequest) (*DescribeCloudProviderCostResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeCloudProviderCostResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CostApiAPIService.CostApiDescribeCloudProviderCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2022-09-01-00/fleet/cost/cloud-provider"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.environmentType == nil {
		return localVarReturnValue, nil, reportError("environmentType is required and must be specified")
	}
	if r.frequency == nil {
		return localVarReturnValue, nil, reportError("frequency is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "environmentType", r.environmentType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", r.frequency, "form", "")
	if r.includeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCloudProviderIDs", r.includeCloudProviderIDs, "form", "")
	}
	if r.excludeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCloudProviderIDs", r.excludeCloudProviderIDs, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCostApiDescribeDeploymentCellCostRequest struct {
	ctx context.Context
	ApiService CostApiAPI
	startDate *time.Time
	endDate *time.Time
	environmentType *string
	frequency *string
	includeCloudProviderIDs *string
	excludeCloudProviderIDs *string
	includeRegionIDs *string
	excludeRegionIDs *string
	includeDeploymentCellIDs *string
	excludeDeploymentCellIDs *string
	includeInstanceIDs *string
	excludeInstanceIDs *string
	topNInstances *int64
}

// The start date of the range
func (r ApiCostApiDescribeDeploymentCellCostRequest) StartDate(startDate time.Time) ApiCostApiDescribeDeploymentCellCostRequest {
	r.startDate = &startDate
	return r
}

// The end date of the range
func (r ApiCostApiDescribeDeploymentCellCostRequest) EndDate(endDate time.Time) ApiCostApiDescribeDeploymentCellCostRequest {
	r.endDate = &endDate
	return r
}

// The type of environment to filter costs by
func (r ApiCostApiDescribeDeploymentCellCostRequest) EnvironmentType(environmentType string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.environmentType = &environmentType
	return r
}

// The frequency of the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) Frequency(frequency string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.frequency = &frequency
	return r
}

// The cloud provider IDs to include in the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) IncludeCloudProviderIDs(includeCloudProviderIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.includeCloudProviderIDs = &includeCloudProviderIDs
	return r
}

// The cloud provider IDs to exclude from the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) ExcludeCloudProviderIDs(excludeCloudProviderIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.excludeCloudProviderIDs = &excludeCloudProviderIDs
	return r
}

// The region IDs to include in the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) IncludeRegionIDs(includeRegionIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.includeRegionIDs = &includeRegionIDs
	return r
}

// The region IDs to exclude from the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) ExcludeRegionIDs(excludeRegionIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.excludeRegionIDs = &excludeRegionIDs
	return r
}

// The deployment cell IDs to include in the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) IncludeDeploymentCellIDs(includeDeploymentCellIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.includeDeploymentCellIDs = &includeDeploymentCellIDs
	return r
}

// The deployment cell IDs to exclude from the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) ExcludeDeploymentCellIDs(excludeDeploymentCellIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.excludeDeploymentCellIDs = &excludeDeploymentCellIDs
	return r
}

// The instance IDs to include in the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) IncludeInstanceIDs(includeInstanceIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.includeInstanceIDs = &includeInstanceIDs
	return r
}

// The instance IDs to exclude from the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) ExcludeInstanceIDs(excludeInstanceIDs string) ApiCostApiDescribeDeploymentCellCostRequest {
	r.excludeInstanceIDs = &excludeInstanceIDs
	return r
}

// The number of top instances to include in the cost data
func (r ApiCostApiDescribeDeploymentCellCostRequest) TopNInstances(topNInstances int64) ApiCostApiDescribeDeploymentCellCostRequest {
	r.topNInstances = &topNInstances
	return r
}

func (r ApiCostApiDescribeDeploymentCellCostRequest) Execute() (*DescribeDeploymentCellCostResult, *http.Response, error) {
	return r.ApiService.CostApiDescribeDeploymentCellCostExecute(r)
}

/*
CostApiDescribeDeploymentCellCost DescribeDeploymentCellCost cost-api

Get the total cost of operating a fleet in a deployment cell

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCostApiDescribeDeploymentCellCostRequest
*/
func (a *CostApiAPIService) CostApiDescribeDeploymentCellCost(ctx context.Context) ApiCostApiDescribeDeploymentCellCostRequest {
	return ApiCostApiDescribeDeploymentCellCostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeDeploymentCellCostResult
func (a *CostApiAPIService) CostApiDescribeDeploymentCellCostExecute(r ApiCostApiDescribeDeploymentCellCostRequest) (*DescribeDeploymentCellCostResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeDeploymentCellCostResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CostApiAPIService.CostApiDescribeDeploymentCellCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2022-09-01-00/fleet/cost/deployment-cell"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.environmentType == nil {
		return localVarReturnValue, nil, reportError("environmentType is required and must be specified")
	}
	if r.frequency == nil {
		return localVarReturnValue, nil, reportError("frequency is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "environmentType", r.environmentType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", r.frequency, "form", "")
	if r.includeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCloudProviderIDs", r.includeCloudProviderIDs, "form", "")
	}
	if r.excludeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCloudProviderIDs", r.excludeCloudProviderIDs, "form", "")
	}
	if r.includeRegionIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRegionIDs", r.includeRegionIDs, "form", "")
	}
	if r.excludeRegionIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRegionIDs", r.excludeRegionIDs, "form", "")
	}
	if r.includeDeploymentCellIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDeploymentCellIDs", r.includeDeploymentCellIDs, "form", "")
	}
	if r.excludeDeploymentCellIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeDeploymentCellIDs", r.excludeDeploymentCellIDs, "form", "")
	}
	if r.includeInstanceIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInstanceIDs", r.includeInstanceIDs, "form", "")
	}
	if r.excludeInstanceIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeInstanceIDs", r.excludeInstanceIDs, "form", "")
	}
	if r.topNInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topNInstances", r.topNInstances, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCostApiDescribeRegionCostRequest struct {
	ctx context.Context
	ApiService CostApiAPI
	startDate *time.Time
	endDate *time.Time
	environmentType *string
	frequency *string
	includeCloudProviderIDs *string
	excludeCloudProviderIDs *string
	includeRegionIDs *string
	excludeRegionIDs *string
}

// The start date of the range
func (r ApiCostApiDescribeRegionCostRequest) StartDate(startDate time.Time) ApiCostApiDescribeRegionCostRequest {
	r.startDate = &startDate
	return r
}

// The end date of the range
func (r ApiCostApiDescribeRegionCostRequest) EndDate(endDate time.Time) ApiCostApiDescribeRegionCostRequest {
	r.endDate = &endDate
	return r
}

// The type of environment to filter costs by
func (r ApiCostApiDescribeRegionCostRequest) EnvironmentType(environmentType string) ApiCostApiDescribeRegionCostRequest {
	r.environmentType = &environmentType
	return r
}

// The frequency of the cost data
func (r ApiCostApiDescribeRegionCostRequest) Frequency(frequency string) ApiCostApiDescribeRegionCostRequest {
	r.frequency = &frequency
	return r
}

// The cloud provider IDs to include in the cost data
func (r ApiCostApiDescribeRegionCostRequest) IncludeCloudProviderIDs(includeCloudProviderIDs string) ApiCostApiDescribeRegionCostRequest {
	r.includeCloudProviderIDs = &includeCloudProviderIDs
	return r
}

// The cloud provider IDs to exclude from the cost data
func (r ApiCostApiDescribeRegionCostRequest) ExcludeCloudProviderIDs(excludeCloudProviderIDs string) ApiCostApiDescribeRegionCostRequest {
	r.excludeCloudProviderIDs = &excludeCloudProviderIDs
	return r
}

// The region IDs to include in the cost data
func (r ApiCostApiDescribeRegionCostRequest) IncludeRegionIDs(includeRegionIDs string) ApiCostApiDescribeRegionCostRequest {
	r.includeRegionIDs = &includeRegionIDs
	return r
}

// The region IDs to exclude from the cost data
func (r ApiCostApiDescribeRegionCostRequest) ExcludeRegionIDs(excludeRegionIDs string) ApiCostApiDescribeRegionCostRequest {
	r.excludeRegionIDs = &excludeRegionIDs
	return r
}

func (r ApiCostApiDescribeRegionCostRequest) Execute() (*DescribeRegionCostResult, *http.Response, error) {
	return r.ApiService.CostApiDescribeRegionCostExecute(r)
}

/*
CostApiDescribeRegionCost DescribeRegionCost cost-api

Get the total cost of operating a fleet in a region

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCostApiDescribeRegionCostRequest
*/
func (a *CostApiAPIService) CostApiDescribeRegionCost(ctx context.Context) ApiCostApiDescribeRegionCostRequest {
	return ApiCostApiDescribeRegionCostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeRegionCostResult
func (a *CostApiAPIService) CostApiDescribeRegionCostExecute(r ApiCostApiDescribeRegionCostRequest) (*DescribeRegionCostResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeRegionCostResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CostApiAPIService.CostApiDescribeRegionCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2022-09-01-00/fleet/cost/region"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.environmentType == nil {
		return localVarReturnValue, nil, reportError("environmentType is required and must be specified")
	}
	if r.frequency == nil {
		return localVarReturnValue, nil, reportError("frequency is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "environmentType", r.environmentType, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "frequency", r.frequency, "form", "")
	if r.includeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeCloudProviderIDs", r.includeCloudProviderIDs, "form", "")
	}
	if r.excludeCloudProviderIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeCloudProviderIDs", r.excludeCloudProviderIDs, "form", "")
	}
	if r.includeRegionIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeRegionIDs", r.includeRegionIDs, "form", "")
	}
	if r.excludeRegionIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeRegionIDs", r.excludeRegionIDs, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCostApiDescribeUserCostRequest struct {
	ctx context.Context
	ApiService CostApiAPI
	startDate *time.Time
	endDate *time.Time
	environmentType *string
	includeUserIDs *string
	excludeUserIDs *string
	topNUsers *int64
	topNInstances *int64
}

// The start date of the range
func (r ApiCostApiDescribeUserCostRequest) StartDate(startDate time.Time) ApiCostApiDescribeUserCostRequest {
	r.startDate = &startDate
	return r
}

// The end date of the range
func (r ApiCostApiDescribeUserCostRequest) EndDate(endDate time.Time) ApiCostApiDescribeUserCostRequest {
	r.endDate = &endDate
	return r
}

// The type of environment to filter costs by
func (r ApiCostApiDescribeUserCostRequest) EnvironmentType(environmentType string) ApiCostApiDescribeUserCostRequest {
	r.environmentType = &environmentType
	return r
}

// The user IDs to include in the cost data
func (r ApiCostApiDescribeUserCostRequest) IncludeUserIDs(includeUserIDs string) ApiCostApiDescribeUserCostRequest {
	r.includeUserIDs = &includeUserIDs
	return r
}

// The user IDs to exclude from the cost data
func (r ApiCostApiDescribeUserCostRequest) ExcludeUserIDs(excludeUserIDs string) ApiCostApiDescribeUserCostRequest {
	r.excludeUserIDs = &excludeUserIDs
	return r
}

// The number of top users to include in the cost data
func (r ApiCostApiDescribeUserCostRequest) TopNUsers(topNUsers int64) ApiCostApiDescribeUserCostRequest {
	r.topNUsers = &topNUsers
	return r
}

// The number of top instances to include in the cost data
func (r ApiCostApiDescribeUserCostRequest) TopNInstances(topNInstances int64) ApiCostApiDescribeUserCostRequest {
	r.topNInstances = &topNInstances
	return r
}

func (r ApiCostApiDescribeUserCostRequest) Execute() (*DescribeUserCostResult, *http.Response, error) {
	return r.ApiService.CostApiDescribeUserCostExecute(r)
}

/*
CostApiDescribeUserCost DescribeUserCost cost-api

Get the total cost of operating a fleet for a user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCostApiDescribeUserCostRequest
*/
func (a *CostApiAPIService) CostApiDescribeUserCost(ctx context.Context) ApiCostApiDescribeUserCostRequest {
	return ApiCostApiDescribeUserCostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DescribeUserCostResult
func (a *CostApiAPIService) CostApiDescribeUserCostExecute(r ApiCostApiDescribeUserCostRequest) (*DescribeUserCostResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DescribeUserCostResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CostApiAPIService.CostApiDescribeUserCost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/2022-09-01-00/fleet/cost/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.environmentType == nil {
		return localVarReturnValue, nil, reportError("environmentType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "environmentType", r.environmentType, "form", "")
	if r.includeUserIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUserIDs", r.includeUserIDs, "form", "")
	}
	if r.excludeUserIDs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeUserIDs", r.excludeUserIDs, "form", "")
	}
	if r.topNUsers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topNUsers", r.topNUsers, "form", "")
	}
	if r.topNInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "topNInstances", r.topNInstances, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/vnd.goa.error"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
